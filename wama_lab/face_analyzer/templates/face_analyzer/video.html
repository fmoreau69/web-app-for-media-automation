{% extends 'face_analyzer/base.html' %}
{% load static %}

{% block face_analyzer_content %}
<div class="container-fluid py-3">
    <div class="row">
        <!-- Left Panel: Video Player & Controls -->
        <div class="col-lg-6 mb-3">
            <!-- Upload / Video Player -->
            <div class="card bg-dark border-success mb-3">
                <div class="card-header bg-success bg-opacity-25 border-success d-flex justify-content-between align-items-center">
                    <h5 class="mb-0 text-success">
                        <i class="fas fa-file-video me-2"></i>Vidéo
                    </h5>
                    <div id="videoInfo" class="small text-secondary"></div>
                </div>
                <div class="card-body p-0 position-relative" id="videoContainer">
                    <!-- Upload Zone (shown when no video) -->
                    <div id="uploadZone" class="p-5 text-center">
                        <input type="file" id="videoInput" accept="video/*" class="d-none">
                        <div class="upload-area py-5 border border-2 border-dashed border-secondary rounded"
                             onclick="document.getElementById('videoInput').click()">
                            <i class="fas fa-cloud-upload-alt fa-4x text-secondary mb-3"></i>
                            <p class="text-light mb-2">Glissez-déposez une vidéo ici</p>
                            <p class="text-secondary small">ou cliquez pour sélectionner</p>
                            <p class="text-secondary small mt-3">Formats supportés: MP4, AVI, MOV, MKV</p>
                        </div>
                    </div>

                    <!-- Video Player (shown when video loaded) -->
                    <div id="playerZone" class="d-none">
                        <video id="videoPlayer" class="w-100" style="max-height: 400px; background: #000;"></video>
                        <canvas id="videoOverlay" class="position-absolute top-0 start-0 w-100 h-100" style="pointer-events: none;"></canvas>
                    </div>
                </div>
            </div>

            <!-- VCR Controls -->
            <div class="card bg-dark border-secondary mb-3" id="controlsCard" style="display: none;">
                <div class="card-body">
                    <!-- Progress Bar -->
                    <div class="mb-3">
                        <div class="d-flex justify-content-between text-secondary small mb-1">
                            <span id="currentTime">00:00</span>
                            <span id="totalTime">00:00</span>
                        </div>
                        <input type="range" class="form-range" id="progressBar" min="0" max="100" value="0">
                    </div>

                    <!-- Playback Controls -->
                    <div class="d-flex justify-content-center align-items-center gap-2 mb-3">
                        <button class="btn btn-outline-secondary btn-sm" id="skipBackward" title="Reculer 10s">
                            <i class="fas fa-backward"></i>
                        </button>
                        <button class="btn btn-outline-secondary" id="stepBackward" title="Image précédente">
                            <i class="fas fa-step-backward"></i>
                        </button>
                        <button class="btn btn-success btn-lg" id="playPauseBtn">
                            <i class="fas fa-play" id="playPauseIcon"></i>
                        </button>
                        <button class="btn btn-outline-secondary" id="stepForward" title="Image suivante">
                            <i class="fas fa-step-forward"></i>
                        </button>
                        <button class="btn btn-outline-secondary btn-sm" id="skipForward" title="Avancer 10s">
                            <i class="fas fa-forward"></i>
                        </button>
                    </div>

                    <!-- Speed & Volume -->
                    <div class="row g-3">
                        <div class="col-6">
                            <label class="form-label text-light small">Vitesse</label>
                            <select id="playbackSpeed" class="form-select form-select-sm bg-dark text-light border-secondary">
                                <option value="0.25">0.25x</option>
                                <option value="0.5">0.5x</option>
                                <option value="1" selected>1x</option>
                                <option value="1.5">1.5x</option>
                                <option value="2">2x</option>
                            </select>
                        </div>
                        <div class="col-6">
                            <label class="form-label text-light small">Volume</label>
                            <input type="range" class="form-range" id="volumeSlider" min="0" max="100" value="100">
                        </div>
                    </div>
                </div>
            </div>

            <!-- Analysis Controls -->
            <div class="card bg-dark border-secondary mb-3" id="analysisCard" style="display: none;">
                <div class="card-body">
                    <div class="row g-3">
                        <!-- Analysis Options -->
                        <div class="col-12">
                            <label class="form-label text-light small">Modules d'analyse</label>
                            <div class="d-flex flex-wrap gap-2">
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="enableRPPG" checked>
                                    <label class="form-check-label text-danger small" for="enableRPPG">
                                        <i class="fas fa-heartbeat me-1"></i>rPPG
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="enableEyes" checked>
                                    <label class="form-check-label text-info small" for="enableEyes">
                                        <i class="fas fa-eye me-1"></i>Oculométrie
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="enableEmotions" checked>
                                    <label class="form-check-label text-warning small" for="enableEmotions">
                                        <i class="fas fa-smile me-1"></i>Émotions
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="enableRespiration" checked>
                                    <label class="form-check-label text-success small" for="enableRespiration">
                                        <i class="fas fa-lungs me-1"></i>Respiration
                                    </label>
                                </div>
                            </div>
                        </div>

                        <!-- Action Buttons -->
                        <div class="col-12">
                            <div class="d-flex gap-2">
                                <button id="analyzeBtn" class="btn btn-success flex-grow-1">
                                    <i class="fas fa-play me-2"></i>Lancer l'analyse
                                </button>
                                <button id="cancelBtn" class="btn btn-danger" style="display: none;">
                                    <i class="fas fa-times me-2"></i>Annuler
                                </button>
                                <button id="exportBtn" class="btn btn-outline-info" disabled>
                                    <i class="fas fa-download me-2"></i>Export
                                </button>
                            </div>
                        </div>

                        <!-- Progress -->
                        <div class="col-12" id="analysisProgress" style="display: none;">
                            <div class="progress bg-secondary" style="height: 25px;">
                                <div id="progressBarAnalysis" class="progress-bar progress-bar-striped progress-bar-animated bg-success"
                                     role="progressbar" style="width: 0%;">
                                    <span id="progressText">0%</span>
                                </div>
                            </div>
                            <div class="d-flex justify-content-between mt-1">
                                <small id="progressStatus" class="text-secondary">Initialisation...</small>
                                <small id="progressETA" class="text-secondary">ETA: --:--</small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Summary Metrics -->
            <div class="row g-2" id="metricsRow" style="display: none;">
                <div class="col-6 col-md-3">
                    <div class="card bg-dark border-danger h-100">
                        <div class="card-body text-center p-2">
                            <i class="fas fa-heartbeat text-danger"></i>
                            <div class="small text-secondary">Fréq. Cardiaque</div>
                            <div id="avgHR" class="fs-5 text-danger fw-bold">--</div>
                            <div class="small text-secondary">moy. BPM</div>
                        </div>
                    </div>
                </div>
                <div class="col-6 col-md-3">
                    <div class="card bg-dark border-warning h-100">
                        <div class="card-body text-center p-2">
                            <i class="fas fa-wave-square text-warning"></i>
                            <div class="small text-secondary">HRV (RMSSD)</div>
                            <div id="avgHRV" class="fs-5 text-warning fw-bold">--</div>
                            <div class="small text-secondary">moy. ms</div>
                        </div>
                    </div>
                </div>
                <div class="col-6 col-md-3">
                    <div class="card bg-dark border-success h-100">
                        <div class="card-body text-center p-2">
                            <i class="fas fa-lungs text-success"></i>
                            <div class="small text-secondary">Respiration</div>
                            <div id="avgRR" class="fs-5 text-success fw-bold">--</div>
                            <div class="small text-secondary">moy. /min</div>
                        </div>
                    </div>
                </div>
                <div class="col-6 col-md-3">
                    <div class="card bg-dark border-info h-100">
                        <div class="card-body text-center p-2">
                            <i class="fas fa-smile text-info"></i>
                            <div class="small text-secondary">Émotion dominante</div>
                            <div id="dominantEmotion" class="fs-5 text-info fw-bold">--</div>
                            <div class="small text-secondary">&nbsp;</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Panel: Charts -->
        <div class="col-lg-6" id="chartsPanel" style="display: none;">
            <!-- Timeline Indicator -->
            <div class="position-relative mb-3">
                <div id="timelineIndicator" class="position-absolute bg-danger"
                     style="width: 2px; height: 100%; left: 0; top: 0; z-index: 100; display: none;"></div>
            </div>

            <!-- Heart Rate Chart -->
            <div class="card bg-dark border-danger mb-3">
                <div class="card-header bg-danger bg-opacity-25 border-danger py-2 d-flex justify-content-between">
                    <h6 class="mb-0 text-danger">
                        <i class="fas fa-heartbeat me-2"></i>Fréquence Cardiaque
                    </h6>
                    <span class="badge bg-danger" id="currentHR">-- BPM</span>
                </div>
                <div class="card-body p-2">
                    <canvas id="hrChart" height="120"></canvas>
                </div>
            </div>

            <!-- HRV Chart -->
            <div class="card bg-dark border-warning mb-3">
                <div class="card-header bg-warning bg-opacity-25 border-warning py-2">
                    <h6 class="mb-0 text-warning">
                        <i class="fas fa-wave-square me-2"></i>Variabilité Cardiaque (HRV)
                    </h6>
                </div>
                <div class="card-body p-2">
                    <canvas id="hrvChart" height="100"></canvas>
                </div>
            </div>

            <!-- Emotions Chart -->
            <div class="card bg-dark border-warning mb-3">
                <div class="card-header bg-warning bg-opacity-25 border-warning py-2">
                    <h6 class="mb-0 text-warning">
                        <i class="fas fa-smile me-2"></i>Émotions (évolution)
                    </h6>
                </div>
                <div class="card-body p-2">
                    <canvas id="emotionsChart" height="120"></canvas>
                </div>
            </div>

            <!-- Eye Tracking -->
            <div class="card bg-dark border-info mb-3">
                <div class="card-header bg-info bg-opacity-25 border-info py-2">
                    <h6 class="mb-0 text-info">
                        <i class="fas fa-eye me-2"></i>Oculométrie
                    </h6>
                </div>
                <div class="card-body p-2">
                    <div class="row">
                        <div class="col-6">
                            <small class="text-secondary">PERCLOS (fatigue)</small>
                            <div style="height: 80px; position: relative;">
                                <canvas id="perclosChart"></canvas>
                            </div>
                        </div>
                        <div class="col-6">
                            <small class="text-secondary">Clignements</small>
                            <div style="height: 80px; position: relative;">
                                <canvas id="blinkChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Respiration Chart -->
            <div class="card bg-dark border-success">
                <div class="card-header bg-success bg-opacity-25 border-success py-2">
                    <h6 class="mb-0 text-success">
                        <i class="fas fa-lungs me-2"></i>Respiration
                    </h6>
                </div>
                <div class="card-body p-2">
                    <canvas id="respirationChart" height="100"></canvas>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block app_scripts %}
<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

<script>
// Configuration
const CONFIG = {
    CREATE_SESSION_URL: "{% url 'wama_lab:face_analyzer:create_session' %}",
    CSRF_TOKEN: "{{ csrf_token }}",
};

// State
let sessionId = null;
let analysisData = null;
let isAnalyzing = false;
let charts = {};
let progressPollTimeout = null; // Track polling timeout to allow cleanup

// DOM Elements
const videoInput = document.getElementById('videoInput');
const uploadZone = document.getElementById('uploadZone');
const playerZone = document.getElementById('playerZone');
const videoPlayer = document.getElementById('videoPlayer');
const videoOverlay = document.getElementById('videoOverlay');
const overlayCtx = videoOverlay.getContext('2d');

const controlsCard = document.getElementById('controlsCard');
const analysisCard = document.getElementById('analysisCard');
const metricsRow = document.getElementById('metricsRow');
const chartsPanel = document.getElementById('chartsPanel');

const playPauseBtn = document.getElementById('playPauseBtn');
const playPauseIcon = document.getElementById('playPauseIcon');
const progressBar = document.getElementById('progressBar');
const currentTimeEl = document.getElementById('currentTime');
const totalTimeEl = document.getElementById('totalTime');

const analyzeBtn = document.getElementById('analyzeBtn');
const cancelBtn = document.getElementById('cancelBtn');
const exportBtn = document.getElementById('exportBtn');

// Initialize
document.addEventListener('DOMContentLoaded', function() {
    setupEventListeners();
    setupDragAndDrop();
    setupGlobalErrorHandlers();

    // Check if session ID passed in URL (only once)
    const urlParams = new URLSearchParams(window.location.search);
    const existingSession = urlParams.get('session');
    if (existingSession && !sessionId) {
        console.log('Loading existing session from URL:', existingSession);
        loadExistingSession(existingSession);
    }
});

// Global error handlers to prevent unhandled promise rejections
function setupGlobalErrorHandlers() {
    // Handle unhandled promise rejections
    window.addEventListener('unhandledrejection', function(event) {
        // Filter out extension-related errors
        if (event.reason && typeof event.reason === 'object' && event.reason.message) {
            if (event.reason.message.includes('message channel closed')) {
                event.preventDefault();
                console.warn('Extension message channel error (can be safely ignored)');
                return;
            }
        }
        
        console.error('Unhandled promise rejection:', event.reason);
        // Prevent the default browser error logging for known issues
        event.preventDefault();
    });

    // Handle general errors
    window.addEventListener('error', function(event) {
        // Filter out extension-related errors
        if (event.message && event.message.includes('message channel closed')) {
            event.preventDefault();
            console.warn('Extension message channel error (can be safely ignored)');
            return false;
        }
    });

    // Cleanup on page unload
    window.addEventListener('beforeunload', function() {
        // Stop any ongoing analysis
        isAnalyzing = false;
        // Clear polling timeout
        if (progressPollTimeout) {
            clearTimeout(progressPollTimeout);
            progressPollTimeout = null;
        }
    });
}

function setupEventListeners() {
    // File input
    videoInput.addEventListener('change', handleFileSelect);

    // Video controls
    playPauseBtn.addEventListener('click', togglePlayPause);
    progressBar.addEventListener('input', seekVideo);
    videoPlayer.addEventListener('timeupdate', updateProgress);
    videoPlayer.addEventListener('loadedmetadata', onVideoLoaded);

    document.getElementById('playbackSpeed').addEventListener('change', e => {
        videoPlayer.playbackRate = parseFloat(e.target.value);
    });

    document.getElementById('volumeSlider').addEventListener('input', e => {
        videoPlayer.volume = e.target.value / 100;
    });

    document.getElementById('skipBackward').addEventListener('click', () => videoPlayer.currentTime -= 10);
    document.getElementById('skipForward').addEventListener('click', () => videoPlayer.currentTime += 10);
    document.getElementById('stepBackward').addEventListener('click', () => videoPlayer.currentTime -= 1/30);
    document.getElementById('stepForward').addEventListener('click', () => videoPlayer.currentTime += 1/30);

    // Analysis controls
    analyzeBtn.addEventListener('click', startAnalysis);
    cancelBtn.addEventListener('click', cancelAnalysis);
    exportBtn.addEventListener('click', exportResults);
}

function setupDragAndDrop() {
    const uploadArea = uploadZone.querySelector('.upload-area');

    uploadArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadArea.classList.add('border-success');
    });

    uploadArea.addEventListener('dragleave', () => {
        uploadArea.classList.remove('border-success');
    });

    uploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadArea.classList.remove('border-success');

        const files = e.dataTransfer.files;
        if (files.length > 0 && files[0].type.startsWith('video/')) {
            handleFile(files[0]);
        }
    });
}

function handleFileSelect(e) {
    const file = e.target.files[0];
    if (file) handleFile(file);
}

function handleFile(file) {
    const url = URL.createObjectURL(file);
    videoPlayer.src = url;

    uploadZone.classList.add('d-none');
    playerZone.classList.remove('d-none');
    controlsCard.style.display = 'block';
    analysisCard.style.display = 'block';

    document.getElementById('videoInfo').textContent = `${file.name} (${formatFileSize(file.size)})`;

    // Store file for upload
    videoInput.uploadFile = file;
}

function onVideoLoaded() {
    totalTimeEl.textContent = formatTime(videoPlayer.duration);
    videoOverlay.width = videoPlayer.videoWidth;
    videoOverlay.height = videoPlayer.videoHeight;
}

function togglePlayPause() {
    if (videoPlayer.paused) {
        videoPlayer.play();
        playPauseIcon.className = 'fas fa-pause';
    } else {
        videoPlayer.pause();
        playPauseIcon.className = 'fas fa-play';
    }
}

function seekVideo() {
    const time = (progressBar.value / 100) * videoPlayer.duration;
    videoPlayer.currentTime = time;
    updateOverlayAtTime(time);
}

function updateProgress() {
    const progress = (videoPlayer.currentTime / videoPlayer.duration) * 100;
    progressBar.value = progress;
    currentTimeEl.textContent = formatTime(videoPlayer.currentTime);

    // Update overlay and charts sync
    if (analysisData) {
        updateOverlayAtTime(videoPlayer.currentTime);
        updateChartIndicator(videoPlayer.currentTime);
    }
}

async function startAnalysis() {
    if (!videoInput.uploadFile) {
        alert('Veuillez d\'abord charger une vidéo');
        return;
    }

    isAnalyzing = true;
    analyzeBtn.style.display = 'none';
    cancelBtn.style.display = 'inline-block';
    document.getElementById('analysisProgress').style.display = 'block';

    try {
        // Create session and upload video
        const formData = new FormData();
        formData.append('video_file', videoInput.uploadFile);
        formData.append('mode', 'video');
        formData.append('enable_rppg', document.getElementById('enableRPPG').checked);
        formData.append('enable_eye_tracking', document.getElementById('enableEyes').checked);
        formData.append('enable_emotions', document.getElementById('enableEmotions').checked);
        formData.append('enable_respiration', document.getElementById('enableRespiration').checked);

        const createResponse = await fetch(CONFIG.CREATE_SESSION_URL, {
            method: 'POST',
            headers: { 'X-CSRFToken': CONFIG.CSRF_TOKEN },
            body: formData
        });

        if (!createResponse.ok) {
            throw new Error(`HTTP error! status: ${createResponse.status}`);
        }

        const createData = await createResponse.json();
        if (!createData.success) throw new Error(createData.error);

        sessionId = createData.session_id;

        // Start analysis
        const startResponse = await fetch(`/lab/face-analyzer/api/sessions/${sessionId}/start/`, {
            method: 'POST',
            headers: { 'X-CSRFToken': CONFIG.CSRF_TOKEN }
        });

        if (!startResponse.ok) throw new Error('Failed to start analysis');

        // Poll for progress
        pollAnalysisProgress();

    } catch (error) {
        console.error('Analysis error:', error);
        alert('Erreur lors de l\'analyse: ' + error.message);
        resetAnalysisUI();
    }
}

async function pollAnalysisProgress() {
    if (!isAnalyzing || !sessionId) {
        // Clear any pending timeout
        if (progressPollTimeout) {
            clearTimeout(progressPollTimeout);
            progressPollTimeout = null;
        }
        return;
    }

    try {
        const response = await fetch(`/lab/face-analyzer/api/sessions/${sessionId}/status/`);
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();

        updateProgressUI(data);

        if (data.status === 'completed') {
            // Only load results if not already loaded
            if (!analysisData || !analysisData.frames || analysisData.frames.length === 0) {
                await loadAnalysisResults();
            } else {
                console.log('Analysis data already loaded, skipping reload');
            }
            // Clear polling
            if (progressPollTimeout) {
                clearTimeout(progressPollTimeout);
                progressPollTimeout = null;
            }
        } else if (data.status === 'failed') {
            throw new Error(data.error || 'Analysis failed');
        } else {
            // Schedule next poll
            progressPollTimeout = setTimeout(() => {
                pollAnalysisProgress().catch(err => {
                    console.error('Polling error:', err);
                    resetAnalysisUI();
                });
            }, 1000);
        }
    } catch (error) {
        console.error('Progress error:', error);
        // Clear polling on error
        if (progressPollTimeout) {
            clearTimeout(progressPollTimeout);
            progressPollTimeout = null;
        }
        alert('Erreur: ' + error.message);
        resetAnalysisUI();
    }
}

function updateProgressUI(data) {
    const progress = data.progress || 0;
    document.getElementById('progressBarAnalysis').style.width = progress + '%';
    document.getElementById('progressText').textContent = progress.toFixed(0) + '%';
    document.getElementById('progressStatus').textContent = data.status_message || 'En cours...';

    if (data.eta) {
        document.getElementById('progressETA').textContent = 'ETA: ' + formatTime(data.eta);
    }
}

let isLoadingResults = false;

async function loadAnalysisResults() {
    // Prevent multiple simultaneous loads
    if (isLoadingResults) {
        console.log('Already loading results, skipping...');
        return;
    }
    
    isLoadingResults = true;
    
    try {
        const response = await fetch(`/lab/face-analyzer/api/sessions/${sessionId}/frames/`);
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        analysisData = await response.json();
        
        console.log('Analysis data loaded:', {
            framesCount: analysisData.frames?.length || 0,
            hasSummary: !!analysisData.summary,
            firstFrame: analysisData.frames?.[0]
        });

        if (!analysisData.frames || analysisData.frames.length === 0) {
            console.warn('No frames found in analysis data');
            alert('Aucune donnée d\'analyse disponible');
            resetAnalysisUI();
            isLoadingResults = false;
            return;
        }

        // Show results UI
        metricsRow.style.display = 'flex';
        chartsPanel.style.display = 'block';
        exportBtn.disabled = false;

        // Initialize charts with data
        initializeCharts();
        populateCharts();
        updateSummaryMetrics();

        resetAnalysisUI();

    } catch (error) {
        console.error('Error loading results:', error);
        alert('Erreur lors du chargement des résultats: ' + error.message);
        resetAnalysisUI();
    } finally {
        isLoadingResults = false;
    }
}

let isLoadingExistingSession = false;

async function loadExistingSession(existingSessionId) {
    // Prevent multiple simultaneous loads
    if (isLoadingExistingSession || isLoadingResults) {
        console.log('Already loading session or results, skipping...');
        return;
    }
    
    isLoadingExistingSession = true;
    sessionId = existingSessionId;
    
    try {
        const statusResponse = await fetch(`/lab/face-analyzer/api/sessions/${sessionId}/status/`);
        
        if (!statusResponse.ok) {
            throw new Error(`HTTP error! status: ${statusResponse.status}`);
        }
        
        const statusData = await statusResponse.json();

        if (statusData.status === 'completed') {
            // Load video file
            if (statusData.input_file) {
                videoPlayer.src = statusData.input_file;
                uploadZone.classList.add('d-none');
                playerZone.classList.remove('d-none');
                controlsCard.style.display = 'block';
                analysisCard.style.display = 'block';
            }

            // Only load results once
            if (!analysisData || !analysisData.frames || analysisData.frames.length === 0) {
                await loadAnalysisResults();
            } else {
                console.log('Analysis data already loaded, skipping reload');
            }
        }
    } catch (error) {
        console.error('Error loading session:', error);
    } finally {
        isLoadingExistingSession = false;
    }
}

async function cancelAnalysis() {
    if (!sessionId) return;

    // Stop polling immediately
    isAnalyzing = false;
    if (progressPollTimeout) {
        clearTimeout(progressPollTimeout);
        progressPollTimeout = null;
    }

    try {
        const response = await fetch(`/lab/face-analyzer/api/sessions/${sessionId}/cancel/`, {
            method: 'POST',
            headers: { 'X-CSRFToken': CONFIG.CSRF_TOKEN }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        if (data.success) {
            console.log('Cancellation requested');
        }
    } catch (error) {
        console.error('Cancel error:', error);
    }

    resetAnalysisUI();
}

function resetAnalysisUI() {
    isAnalyzing = false;
    // Clear any pending polling
    if (progressPollTimeout) {
        clearTimeout(progressPollTimeout);
        progressPollTimeout = null;
    }
    analyzeBtn.style.display = 'inline-block';
    cancelBtn.style.display = 'none';
    document.getElementById('analysisProgress').style.display = 'none';
}

function initializeCharts() {
    // Destroy existing charts if they exist
    Object.keys(charts).forEach(key => {
        if (charts[key]) {
            charts[key].destroy();
            charts[key] = null;
        }
    });

        const chartOptions = {
        responsive: true,
        maintainAspectRatio: true,
        animation: false,
        plugins: { 
            legend: { display: false },
            tooltip: {
                enabled: true,
                mode: 'index',
                intersect: false
            }
        },
        scales: {
            x: { 
                display: false
            },
            y: {
                grid: { color: 'rgba(255,255,255,0.1)' },
                ticks: { color: '#aaa' }
            }
        },
        onClick: (e, elements, chart) => {
            const canvasPosition = Chart.helpers.getRelativePosition(e, chart);
            const dataX = chart.scales.x.getValueForPixel(canvasPosition.x);
            if (analysisData && analysisData.frames && analysisData.frames[Math.round(dataX)]) {
                const timestamp = analysisData.frames[Math.round(dataX)].timestamp;
                videoPlayer.currentTime = timestamp;
            }
        }
    };

    // Heart Rate
    const hrCanvas = document.getElementById('hrChart');
    if (hrCanvas) {
        charts.hr = new Chart(hrCanvas, {
            type: 'line',
            data: { 
                labels: [], 
                datasets: [{ 
                    data: [], 
                    borderColor: '#dc3545', 
                    backgroundColor: 'rgba(220, 53, 69, 0.1)',
                    tension: 0.4, 
                    pointRadius: 2,
                    pointHoverRadius: 4,
                    spanGaps: true
                }] 
            },
            options: { 
                ...chartOptions, 
                scales: { 
                    x: { display: true, title: { display: true, text: 'Temps', color: '#aaa' } },
                    ...chartOptions.scales, 
                    y: { ...chartOptions.scales.y, min: 40, max: 180, title: { display: true, text: 'BPM', color: '#aaa' } } 
                } 
            }
        });
    }

    // HRV
    const hrvCanvas = document.getElementById('hrvChart');
    if (hrvCanvas) {
        charts.hrv = new Chart(hrvCanvas, {
            type: 'line',
            data: { 
                labels: [], 
                datasets: [{ 
                    data: [], 
                    borderColor: '#ffc107', 
                    backgroundColor: 'rgba(255, 193, 7, 0.1)',
                    tension: 0.4, 
                    pointRadius: 2,
                    pointHoverRadius: 4,
                    spanGaps: true
                }] 
            },
            options: { 
                ...chartOptions, 
                scales: { 
                    x: { display: true, title: { display: true, text: 'Temps', color: '#aaa' } },
                    ...chartOptions.scales, 
                    y: { ...chartOptions.scales.y, min: 0, max: 100, title: { display: true, text: 'ms', color: '#aaa' } } 
                } 
            }
        });
    }

    // Emotions (stacked area)
    const emotionsCanvas = document.getElementById('emotionsChart');
    if (emotionsCanvas) {
        charts.emotions = new Chart(emotionsCanvas, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    { label: 'Neutre', data: [], borderColor: '#6c757d', backgroundColor: 'rgba(108,117,125,0.3)', fill: true, tension: 0.4, pointRadius: 0 },
                    { label: 'Joie', data: [], borderColor: '#ffc107', backgroundColor: 'rgba(255,193,7,0.3)', fill: true, tension: 0.4, pointRadius: 0 },
                    { label: 'Tristesse', data: [], borderColor: '#0d6efd', backgroundColor: 'rgba(13,110,253,0.3)', fill: true, tension: 0.4, pointRadius: 0 },
                    { label: 'Colère', data: [], borderColor: '#dc3545', backgroundColor: 'rgba(220,53,69,0.3)', fill: true, tension: 0.4, pointRadius: 0 },
                    { label: 'Surprise', data: [], borderColor: '#0dcaf0', backgroundColor: 'rgba(13,202,240,0.3)', fill: true, tension: 0.4, pointRadius: 0 }
                ]
            },
            options: { ...chartOptions, plugins: { legend: { display: true, labels: { color: '#aaa', boxWidth: 10 } } } }
        });
    }

    // PERCLOS
    const perclosCanvas = document.getElementById('perclosChart');
    if (perclosCanvas) {
        charts.perclos = new Chart(perclosCanvas, {
            type: 'line',
            data: { 
                labels: [], 
                datasets: [{ 
                    data: [], 
                    borderColor: '#0dcaf0', 
                    tension: 0.4, 
                    pointRadius: 1,
                    pointHoverRadius: 3,
                    fill: true, 
                    backgroundColor: 'rgba(13,202,240,0.2)' 
                }] 
            },
            options: { 
                ...chartOptions, 
                scales: { 
                    x: { display: false },
                    ...chartOptions.scales, 
                    y: { ...chartOptions.scales.y, min: 0, max: 100 } 
                },
                maintainAspectRatio: true,
                aspectRatio: 2
            }
        });
    }

    // Blink rate
    const blinkCanvas = document.getElementById('blinkChart');
    if (blinkCanvas) {
        charts.blink = new Chart(blinkCanvas, {
            type: 'bar',
            data: { labels: [], datasets: [{ data: [], backgroundColor: '#0dcaf0' }] },
            options: {
                ...chartOptions,
                scales: {
                    x: { display: false },
                    ...chartOptions.scales
                },
                maintainAspectRatio: true,
                aspectRatio: 2
            }
        });
    }

    // Respiration
    const respirationCanvas = document.getElementById('respirationChart');
    if (respirationCanvas) {
        charts.respiration = new Chart(respirationCanvas, {
            type: 'line',
            data: { 
                labels: [], 
                datasets: [{ 
                    data: [], 
                    borderColor: '#198754', 
                    backgroundColor: 'rgba(25,135,84,0.1)',
                    tension: 0.4, 
                    pointRadius: 2,
                    pointHoverRadius: 4,
                    fill: true, 
                    spanGaps: true
                }] 
            },
            options: { 
                ...chartOptions, 
                scales: { 
                    x: { display: true, title: { display: true, text: 'Temps', color: '#aaa' } },
                    ...chartOptions.scales, 
                    y: { ...chartOptions.scales.y, min: 8, max: 25, title: { display: true, text: 'Resp/min', color: '#aaa' } } 
                } 
            }
        });
    }

    console.log('Charts initialized:', Object.keys(charts));
}

function populateCharts() {
    if (!analysisData || !analysisData.frames) {
        console.warn('No analysis data or frames available for charts');
        return;
    }

    const frames = analysisData.frames;
    if (frames.length === 0) {
        console.warn('Frames array is empty');
        return;
    }

    // Use timestamps as labels for better visualization
    const labels = frames.map(f => formatTime(f.timestamp || 0));
    console.log(`Populating charts with ${frames.length} frames`);

    // Heart Rate
    if (charts.hr) {
        const hrData = frames.map(f => {
            if (f.rppg && typeof f.rppg === 'object') {
                const hr = f.rppg.heart_rate || f.rppg.hr;
                return hr !== undefined && hr !== null ? hr : null;
            }
            return null;
        });
        
        charts.hr.data.labels = labels;
        charts.hr.data.datasets[0].data = hrData;
        charts.hr.update('none');
        console.log(`HR chart: ${hrData.filter(v => v !== null).length} non-null values out of ${frames.length} frames`);
    }

    // HRV
    if (charts.hrv) {
        const hrvData = frames.map(f => {
            if (f.rppg && f.rppg.hrv) {
                const rmssd = f.rppg.hrv.rmssd || f.rppg.hrv.rmssd_value;
                return rmssd !== undefined && rmssd !== null ? rmssd : null;
            }
            if (f.rppg && f.rppg.rmssd !== undefined) {
                return f.rppg.rmssd;
            }
            return null;
        });
        
        charts.hrv.data.labels = labels;
        charts.hrv.data.datasets[0].data = hrvData;
        charts.hrv.update('none');
        console.log(`HRV chart: ${hrvData.filter(v => v !== null).length} non-null values out of ${frames.length} frames`);
    }

    // Emotions
    if (charts.emotions) {
        const emotionKeys = ['neutral', 'happy', 'sad', 'angry', 'surprise'];
        charts.emotions.data.labels = labels;
        emotionKeys.forEach((key, i) => {
            if (charts.emotions.data.datasets[i]) {
                charts.emotions.data.datasets[i].data = frames.map(f => {
                    if (f.emotions && typeof f.emotions === 'object') {
                        return f.emotions[key] || f.emotions[key.toLowerCase()] || 0;
                    }
                    return 0;
                });
            }
        });
        charts.emotions.update('none');
    }

    // PERCLOS
    if (charts.perclos) {
        const perclosData = frames.map(f => {
            if (f.eye_tracking && typeof f.eye_tracking === 'object') {
                const perclos = f.eye_tracking.perclos || f.eye_tracking.perclos_value || 0;
                return perclos * 100; // Convert to percentage
            }
            return 0;
        });
        charts.perclos.data.labels = labels;
        charts.perclos.data.datasets[0].data = perclosData;
        charts.perclos.update('none');
    }

    // Blink (aggregate per second)
    if (charts.blink) {
        const blinkData = aggregateBlinkData(frames);
        charts.blink.data.labels = blinkData.labels;
        charts.blink.data.datasets[0].data = blinkData.values;
        charts.blink.update('none');
    }

    // Respiration
    if (charts.respiration) {
        const respData = frames.map(f => {
            if (f.respiration && typeof f.respiration === 'object') {
                const rate = f.respiration.rate || f.respiration.respiratory_rate;
                return rate !== undefined && rate !== null ? rate : null;
            }
            return null;
        });
        
        charts.respiration.data.labels = labels;
        charts.respiration.data.datasets[0].data = respData;
        charts.respiration.update('none');
        console.log(`Respiration chart: ${respData.filter(v => v !== null).length} non-null values out of ${frames.length} frames`);
    }

    console.log('Charts populated successfully');
}

function aggregateBlinkData(frames) {
    const buckets = {};
    frames.forEach(f => {
        if (f.eye_tracking?.blink_detected) {
            const second = Math.floor(f.timestamp);
            buckets[second] = (buckets[second] || 0) + 1;
        }
    });

    const maxSecond = Math.max(...Object.keys(buckets).map(Number), 0);
    const labels = [];
    const values = [];
    for (let i = 0; i <= maxSecond; i++) {
        labels.push(formatTime(i));
        values.push(buckets[i] || 0);
    }
    return { labels, values };
}

function updateSummaryMetrics() {
    if (!analysisData || !analysisData.summary) {
        console.warn('No summary data available');
        // Try to calculate from frames if summary is missing
        if (analysisData && analysisData.frames && analysisData.frames.length > 0) {
            calculateSummaryFromFrames();
        }
        return;
    }

    const summary = analysisData.summary;
    console.log('Updating summary metrics:', summary);

    const avgHR = summary.avg_heart_rate;
    const avgHRV = summary.avg_hrv;
    const avgRR = summary.avg_respiration;
    const dominantEmotion = summary.dominant_emotion;

    if (document.getElementById('avgHR')) {
        document.getElementById('avgHR').textContent = (avgHR !== undefined && avgHR !== null) ? avgHR.toFixed(0) : '--';
    }
    if (document.getElementById('avgHRV')) {
        document.getElementById('avgHRV').textContent = (avgHRV !== undefined && avgHRV !== null) ? avgHRV.toFixed(1) : '--';
    }
    if (document.getElementById('avgRR')) {
        document.getElementById('avgRR').textContent = (avgRR !== undefined && avgRR !== null) ? avgRR.toFixed(1) : '--';
    }
    if (document.getElementById('dominantEmotion')) {
        document.getElementById('dominantEmotion').textContent = dominantEmotion || '--';
    }
}

function calculateSummaryFromFrames() {
    if (!analysisData || !analysisData.frames || analysisData.frames.length === 0) return;

    const frames = analysisData.frames;
    const hrValues = [];
    const hrvValues = [];
    const rrValues = [];
    const emotions = {};

    frames.forEach(f => {
        if (f.rppg && f.rppg.heart_rate !== undefined && f.rppg.heart_rate !== null) {
            hrValues.push(f.rppg.heart_rate);
        }
        if (f.rppg && f.rppg.hrv && f.rppg.hrv.rmssd !== undefined && f.rppg.hrv.rmssd !== null) {
            hrvValues.push(f.rppg.hrv.rmssd);
        }
        if (f.respiration && f.respiration.rate !== undefined && f.respiration.rate !== null) {
            rrValues.push(f.respiration.rate);
        }
        if (f.emotions && f.emotions.dominant) {
            emotions[f.emotions.dominant] = (emotions[f.emotions.dominant] || 0) + 1;
        }
    });

    const summary = {};
    if (hrValues.length > 0) {
        summary.avg_heart_rate = hrValues.reduce((a, b) => a + b, 0) / hrValues.length;
    }
    if (hrvValues.length > 0) {
        summary.avg_hrv = hrvValues.reduce((a, b) => a + b, 0) / hrvValues.length;
    }
    if (rrValues.length > 0) {
        summary.avg_respiration = rrValues.reduce((a, b) => a + b, 0) / rrValues.length;
    }
    if (Object.keys(emotions).length > 0) {
        summary.dominant_emotion = Object.entries(emotions).reduce((a, b) => a[1] > b[1] ? a : b)[0];
    }

    if (Object.keys(summary).length > 0) {
        analysisData.summary = summary;
        updateSummaryMetrics();
    }
}

function updateOverlayAtTime(time) {
    if (!analysisData || !analysisData.frames) return;

    // Find frame closest to current time
    const frameIndex = analysisData.frames.findIndex(f => f.timestamp >= time);
    if (frameIndex < 0) return;

    const frame = analysisData.frames[frameIndex];

    overlayCtx.clearRect(0, 0, videoOverlay.width, videoOverlay.height);

    // Draw face bbox
    if (frame.face_bbox) {
        const [x, y, w, h] = frame.face_bbox;
        overlayCtx.strokeStyle = '#0dcaf0';
        overlayCtx.lineWidth = 2;
        overlayCtx.strokeRect(x, y, w, h);
    }

    // Draw HR
    if (frame.rppg?.heart_rate) {
        overlayCtx.fillStyle = '#dc3545';
        overlayCtx.font = 'bold 20px Arial';
        overlayCtx.fillText('❤ ' + frame.rppg.heart_rate.toFixed(0) + ' BPM', 10, 30);
        document.getElementById('currentHR').textContent = frame.rppg.heart_rate.toFixed(0) + ' BPM';
    }

    // Draw emotion
    if (frame.emotions?.dominant) {
        overlayCtx.fillStyle = '#ffc107';
        overlayCtx.font = 'bold 16px Arial';
        overlayCtx.fillText(frame.emotions.dominant.toUpperCase(), 10, videoOverlay.height - 10);
    }
}

function updateChartIndicator(time) {
    // TODO: Draw vertical line on charts at current time position
}

function exportResults() {
    if (!analysisData) return;

    const blob = new Blob([JSON.stringify(analysisData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `face_analysis_${sessionId || 'export'}.json`;
    a.click();
    URL.revokeObjectURL(url);
}

// Utility functions
function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

function formatFileSize(bytes) {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
    return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
}
</script>

<style>
.upload-area {
    cursor: pointer;
    transition: border-color 0.2s, background-color 0.2s;
}

.upload-area:hover {
    border-color: #198754 !important;
    background-color: rgba(25, 135, 84, 0.1);
}

.border-dashed {
    border-style: dashed !important;
}

#videoPlayer {
    display: block;
}

.progress {
    border-radius: 0.25rem;
}
</style>
{% endblock %}
