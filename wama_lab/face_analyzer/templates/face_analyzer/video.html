{% extends 'face_analyzer/base.html' %}
{% load static %}

{% block face_analyzer_content %}
<div class="container-fluid py-3">
    <div class="row">
        <!-- Left Panel: Video Player & Controls -->
        <div class="col-lg-6 mb-3">
            <!-- Upload / Video Player -->
            <div class="card bg-dark border-success mb-3">
                <div class="card-header bg-success bg-opacity-25 border-success d-flex justify-content-between align-items-center">
                    <h5 class="mb-0 text-success">
                        <i class="fas fa-file-video me-2"></i>Vidéo
                    </h5>
                    <div id="videoInfo" class="small text-secondary"></div>
                </div>
                <div class="card-body p-0 position-relative" id="videoContainer">
                    <!-- Upload Zone (shown when no video) -->
                    <div id="uploadZone" class="p-5 text-center">
                        <input type="file" id="videoInput" accept="video/*" class="d-none">
                        <div class="upload-area drop-zone py-5 border border-2 border-dashed border-secondary rounded"
                             id="dropZoneFaceAnalyzer"
                             onclick="document.getElementById('videoInput').click()">
                            <i class="fas fa-cloud-upload-alt fa-4x text-secondary mb-3"></i>
                            <p class="text-light mb-2">Glissez-déposez une vidéo ici</p>
                            <p class="text-secondary small">ou cliquez pour sélectionner</p>
                            <p class="text-secondary small mt-3">Formats supportés: MP4, AVI, MOV, MKV</p>
                        </div>
                    </div>

                    <!-- Video Player (shown when video loaded) -->
                    <div id="playerZone" class="d-none">
                        <video id="videoPlayer" class="w-100" style="max-height: 400px; background: #000;"></video>
                        <canvas id="videoOverlay" class="position-absolute top-0 start-0 w-100 h-100" style="pointer-events: none;"></canvas>
                    </div>
                </div>
            </div>

            <!-- VCR Controls -->
            <div class="card bg-dark border-secondary mb-3" id="controlsCard" style="display: none;">
                <div class="card-body">
                    <!-- Progress Bar -->
                    <div class="mb-3">
                        <div class="d-flex justify-content-between text-secondary small mb-1">
                            <span id="currentTime">00:00</span>
                            <span id="totalTime">00:00</span>
                        </div>
                        <input type="range" class="form-range" id="progressBar" min="0" max="100" value="0">
                    </div>

                    <!-- Playback Controls -->
                    <div class="d-flex justify-content-center align-items-center gap-2 mb-3">
                        <button class="btn btn-outline-secondary btn-sm" id="skipBackward" title="Reculer 10s">
                            <i class="fas fa-backward"></i>
                        </button>
                        <button class="btn btn-outline-secondary" id="stepBackward" title="Image précédente">
                            <i class="fas fa-step-backward"></i>
                        </button>
                        <button class="btn btn-success btn-lg" id="playPauseBtn">
                            <i class="fas fa-play" id="playPauseIcon"></i>
                        </button>
                        <button class="btn btn-outline-secondary" id="stepForward" title="Image suivante">
                            <i class="fas fa-step-forward"></i>
                        </button>
                        <button class="btn btn-outline-secondary btn-sm" id="skipForward" title="Avancer 10s">
                            <i class="fas fa-forward"></i>
                        </button>
                        <button class="btn btn-outline-info btn-sm ms-3" id="fullscreenBtn" title="Plein écran">
                            <i class="fas fa-expand" id="fullscreenIcon"></i>
                        </button>
                    </div>

                    <!-- Speed & Volume -->
                    <div class="row g-3">
                        <div class="col-6">
                            <label class="form-label text-light small">Vitesse</label>
                            <select id="playbackSpeed" class="form-select form-select-sm bg-dark text-light border-secondary">
                                <option value="0.25">0.25x</option>
                                <option value="0.5">0.5x</option>
                                <option value="1" selected>1x</option>
                                <option value="1.5">1.5x</option>
                                <option value="2">2x</option>
                            </select>
                        </div>
                        <div class="col-6">
                            <label class="form-label text-light small">Volume</label>
                            <input type="range" class="form-range" id="volumeSlider" min="0" max="100" value="100">
                        </div>
                    </div>
                </div>
            </div>

            <!-- Analysis Controls -->
            <div class="card bg-dark border-secondary mb-3" id="analysisCard" style="display: none;">
                <div class="card-body">
                    <div class="row g-3">
                        <!-- Analysis Options -->
                        <div class="col-12">
                            <label class="form-label text-light small">Modules d'analyse</label>
                            <div class="d-flex flex-wrap gap-2">
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="enableRPPG" checked>
                                    <label class="form-check-label text-danger small" for="enableRPPG">
                                        <i class="fas fa-heartbeat me-1"></i>rPPG
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="enableEyes" checked>
                                    <label class="form-check-label text-info small" for="enableEyes">
                                        <i class="fas fa-eye me-1"></i>Oculométrie
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="enableEmotions" checked>
                                    <label class="form-check-label text-warning small" for="enableEmotions">
                                        <i class="fas fa-smile me-1"></i>Émotions
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="enableRespiration" checked>
                                    <label class="form-check-label text-success small" for="enableRespiration">
                                        <i class="fas fa-lungs me-1"></i>Respiration
                                    </label>
                                </div>
                            </div>
                        </div>

                        <!-- Emotion Backend Selection -->
                        <div class="col-md-6">
                            <label class="form-label text-light small">Backend émotions</label>
                            <select id="emotionBackend" class="form-select form-select-sm bg-dark text-light border-secondary">
                                <option value="fer">FER (rapide)</option>
                                <option value="deepface" selected>DeepFace (complet)</option>
                            </select>
                        </div>

                        <!-- Age/Gender Toggle -->
                        <div class="col-md-6">
                            <label class="form-label text-light small">Options DeepFace</label>
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="enableAgeGender" checked>
                                <label class="form-check-label text-light small" for="enableAgeGender">
                                    <i class="fas fa-user-tag me-1"></i>Âge & Genre
                                </label>
                            </div>
                        </div>

                        <!-- Action Buttons -->
                        <div class="col-12">
                            <div class="d-flex gap-2">
                                <button id="analyzeBtn" class="btn btn-success flex-grow-1">
                                    <i class="fas fa-play me-2"></i>Lancer l'analyse
                                </button>
                                <button id="cancelBtn" class="btn btn-danger" style="display: none;">
                                    <i class="fas fa-times me-2"></i>Annuler
                                </button>
                                <button id="exportBtn" class="btn btn-outline-info" disabled>
                                    <i class="fas fa-download me-2"></i>Export
                                </button>
                            </div>
                        </div>

                        <!-- Progress -->
                        <div class="col-12" id="analysisProgress" style="display: none;">
                            <div class="progress bg-secondary" style="height: 25px;">
                                <div id="progressBarAnalysis" class="progress-bar progress-bar-striped progress-bar-animated bg-success"
                                     role="progressbar" style="width: 0%;">
                                    <span id="progressText">0%</span>
                                </div>
                            </div>
                            <div class="d-flex justify-content-between mt-1">
                                <small id="progressStatus" class="text-secondary">Initialisation...</small>
                                <small id="progressETA" class="text-secondary">ETA: --:--</small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Summary Metrics -->
            <div class="row g-2" id="metricsRow" style="display: none;">
                <div class="col-6 col-md-2">
                    <div class="card bg-dark border-danger h-100">
                        <div class="card-body text-center p-2">
                            <i class="fas fa-heartbeat text-danger"></i>
                            <div id="avgHR" class="fs-5 text-danger fw-bold">--</div>
                            <div class="small text-secondary">BPM moy.</div>
                        </div>
                    </div>
                </div>
                <div class="col-6 col-md-2">
                    <div class="card bg-dark border-primary h-100">
                        <div class="card-body text-center p-2">
                            <i class="fas fa-tint text-primary"></i>
                            <div id="avgSpO2" class="fs-5 text-primary fw-bold">--</div>
                            <div class="small text-secondary">SpO2 %</div>
                        </div>
                    </div>
                </div>
                <div class="col-6 col-md-2">
                    <div class="card bg-dark border-success h-100">
                        <div class="card-body text-center p-2">
                            <i class="fas fa-lungs text-success"></i>
                            <div id="avgRR" class="fs-5 text-success fw-bold">--</div>
                            <div class="small text-secondary">Resp/min</div>
                        </div>
                    </div>
                </div>
                <div class="col-6 col-md-2">
                    <div class="card bg-dark border-info h-100">
                        <div class="card-body text-center p-2">
                            <i class="fas fa-eye text-info"></i>
                            <div id="avgBlink" class="fs-5 text-info fw-bold">--</div>
                            <div class="small text-secondary">Clignt/min</div>
                        </div>
                    </div>
                </div>
                <div class="col-6 col-md-2" id="ageCard">
                    <div class="card bg-dark border-warning h-100">
                        <div class="card-body text-center p-2">
                            <i class="fas fa-birthday-cake text-warning"></i>
                            <div id="detectedAge" class="fs-5 text-warning fw-bold">--</div>
                            <div class="small text-secondary">Âge</div>
                        </div>
                    </div>
                </div>
                <div class="col-6 col-md-2" id="genderCard">
                    <div class="card bg-dark border-secondary h-100">
                        <div class="card-body text-center p-2">
                            <i id="genderIcon" class="fas fa-user text-secondary"></i>
                            <div id="detectedGender" class="fs-5 text-light fw-bold">--</div>
                            <div class="small text-secondary">Genre</div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Second row: HRV and Emotion -->
            <div class="row g-2 mt-1" id="metricsRow2" style="display: none;">
                <div class="col-6">
                    <div class="card bg-dark border-warning h-100">
                        <div class="card-body text-center p-2">
                            <i class="fas fa-wave-square text-warning"></i>
                            <span class="small text-secondary ms-2">HRV (RMSSD)</span>
                            <span id="avgHRV" class="fs-6 text-warning fw-bold ms-2">-- ms</span>
                        </div>
                    </div>
                </div>
                <div class="col-6">
                    <div class="card bg-dark border-info h-100">
                        <div class="card-body text-center p-2">
                            <i class="fas fa-smile text-info"></i>
                            <span class="small text-secondary ms-2">Émotion dominante</span>
                            <span id="dominantEmotion" class="fs-6 text-info fw-bold ms-2">--</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Panel: Charts -->
        <div class="col-lg-6" id="chartsPanel" style="display: none;">
            <!-- Timeline Indicator -->
            <div class="position-relative mb-3">
                <div id="timelineIndicator" class="position-absolute bg-danger"
                     style="width: 2px; height: 100%; left: 0; top: 0; z-index: 100; display: none;"></div>
            </div>

            <!-- Heart Rate Chart -->
            <div class="card bg-dark border-danger mb-3">
                <div class="card-header bg-danger bg-opacity-25 border-danger py-2 d-flex justify-content-between">
                    <h6 class="mb-0 text-danger">
                        <i class="fas fa-heartbeat me-2"></i>Fréquence Cardiaque
                    </h6>
                    <span class="badge bg-danger" id="currentHR">-- BPM</span>
                </div>
                <div class="card-body p-2">
                    <canvas id="hrChart" height="120"></canvas>
                </div>
            </div>

            <!-- HRV Chart -->
            <div class="card bg-dark border-warning mb-3">
                <div class="card-header bg-warning bg-opacity-25 border-warning py-2 d-flex justify-content-between">
                    <h6 class="mb-0 text-warning">
                        <i class="fas fa-wave-square me-2"></i>Variabilité Cardiaque (HRV)
                    </h6>
                    <span class="badge bg-warning text-dark" id="currentHRV">-- ms</span>
                </div>
                <div class="card-body p-2">
                    <canvas id="hrvChart" height="100"></canvas>
                </div>
            </div>

            <!-- Emotions Chart -->
            <div class="card bg-dark border-warning mb-3">
                <div class="card-header bg-warning bg-opacity-25 border-warning py-2 d-flex justify-content-between">
                    <h6 class="mb-0 text-warning">
                        <i class="fas fa-smile me-2"></i>Émotions (évolution)
                    </h6>
                    <span class="badge bg-warning text-dark" id="currentEmotion">--</span>
                </div>
                <div class="card-body p-2">
                    <canvas id="emotionsChart" height="120"></canvas>
                </div>
            </div>

            <!-- Eye Tracking -->
            <div class="card bg-dark border-info mb-3">
                <div class="card-header bg-info bg-opacity-25 border-info py-2 d-flex justify-content-between">
                    <h6 class="mb-0 text-info">
                        <i class="fas fa-eye me-2"></i>Oculométrie
                    </h6>
                    <span class="badge bg-info text-dark" id="currentPERCLOS">-- %</span>
                </div>
                <div class="card-body p-2">
                    <small class="text-secondary">PERCLOS (fatigue) &amp; Clignements</small>
                    <div style="height: 150px; position: relative;">
                        <canvas id="perclosChart"></canvas>
                    </div>
                    <small class="text-secondary mt-2 d-block">Fréquence des clignements (par seconde)</small>
                    <div style="height: 100px; position: relative;">
                        <canvas id="blinkChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Respiration Chart -->
            <div class="card bg-dark border-success">
                <div class="card-header bg-success bg-opacity-25 border-success py-2 d-flex justify-content-between">
                    <h6 class="mb-0 text-success">
                        <i class="fas fa-lungs me-2"></i>Respiration
                    </h6>
                    <span class="badge bg-success" id="currentRespiration">-- /min</span>
                </div>
                <div class="card-body p-2">
                    <canvas id="respirationChart" height="100"></canvas>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block app_scripts %}
<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

<script>
// Configuration
const CONFIG = {
    CREATE_SESSION_URL: "{% url 'wama_lab:face_analyzer:create_session' %}",
    CSRF_TOKEN: "{{ csrf_token }}",
};

// State
let sessionId = null;
let analysisData = null;
let isAnalyzing = false;
let charts = {};
let progressPollTimeout = null; // Track polling timeout to allow cleanup
let currentVideoFilename = null; // Track current video filename

// DOM Elements
const videoInput = document.getElementById('videoInput');
const uploadZone = document.getElementById('uploadZone');
const playerZone = document.getElementById('playerZone');
const videoPlayer = document.getElementById('videoPlayer');
const videoOverlay = document.getElementById('videoOverlay');
const overlayCtx = videoOverlay.getContext('2d');

const controlsCard = document.getElementById('controlsCard');
const analysisCard = document.getElementById('analysisCard');
const metricsRow = document.getElementById('metricsRow');
const chartsPanel = document.getElementById('chartsPanel');

const playPauseBtn = document.getElementById('playPauseBtn');
const playPauseIcon = document.getElementById('playPauseIcon');
const progressBar = document.getElementById('progressBar');
const currentTimeEl = document.getElementById('currentTime');
const totalTimeEl = document.getElementById('totalTime');

const analyzeBtn = document.getElementById('analyzeBtn');
const cancelBtn = document.getElementById('cancelBtn');
const exportBtn = document.getElementById('exportBtn');

// Initialize
document.addEventListener('DOMContentLoaded', function() {
    setupEventListeners();
    setupDragAndDrop();
    setupGlobalErrorHandlers();

    // Check if session ID passed in URL (only once)
    const urlParams = new URLSearchParams(window.location.search);
    const existingSession = urlParams.get('session');
    if (existingSession && !sessionId) {
        console.log('Loading existing session from URL:', existingSession);
        loadExistingSession(existingSession);
    }
});

// Global error handlers to prevent unhandled promise rejections
function setupGlobalErrorHandlers() {
    // Handle unhandled promise rejections
    window.addEventListener('unhandledrejection', function(event) {
        // Filter out extension-related errors
        if (event.reason && typeof event.reason === 'object' && event.reason.message) {
            if (event.reason.message.includes('message channel closed')) {
                event.preventDefault();
                console.warn('Extension message channel error (can be safely ignored)');
                return;
            }
        }
        
        console.error('Unhandled promise rejection:', event.reason);
        // Prevent the default browser error logging for known issues
        event.preventDefault();
    });

    // Handle general errors
    window.addEventListener('error', function(event) {
        // Filter out extension-related errors
        if (event.message && event.message.includes('message channel closed')) {
            event.preventDefault();
            console.warn('Extension message channel error (can be safely ignored)');
            return false;
        }
    });

    // Cleanup on page unload
    window.addEventListener('beforeunload', function() {
        // Stop any ongoing analysis
        isAnalyzing = false;
        // Clear polling timeout
        if (progressPollTimeout) {
            clearTimeout(progressPollTimeout);
            progressPollTimeout = null;
        }
    });
}

let isSeeking = false;  // Flag to prevent progress bar update while user is dragging

function setupEventListeners() {
    // File input
    videoInput.addEventListener('change', handleFileSelect);

    // Video controls
    playPauseBtn.addEventListener('click', togglePlayPause);

    // Progress bar: prevent update conflicts while user is dragging
    progressBar.addEventListener('mousedown', () => { isSeeking = true; });
    progressBar.addEventListener('touchstart', () => { isSeeking = true; });
    progressBar.addEventListener('input', seekVideo);
    progressBar.addEventListener('mouseup', () => { isSeeking = false; });
    progressBar.addEventListener('touchend', () => { isSeeking = false; });
    progressBar.addEventListener('change', () => { isSeeking = false; seekVideo(); });

    videoPlayer.addEventListener('timeupdate', updateProgress);
    videoPlayer.addEventListener('loadedmetadata', onVideoLoaded);

    document.getElementById('playbackSpeed').addEventListener('change', e => {
        videoPlayer.playbackRate = parseFloat(e.target.value);
    });

    document.getElementById('volumeSlider').addEventListener('input', e => {
        videoPlayer.volume = e.target.value / 100;
    });

    document.getElementById('skipBackward').addEventListener('click', () => videoPlayer.currentTime -= 10);
    document.getElementById('skipForward').addEventListener('click', () => videoPlayer.currentTime += 10);
    document.getElementById('stepBackward').addEventListener('click', () => videoPlayer.currentTime -= 1/30);
    document.getElementById('stepForward').addEventListener('click', () => videoPlayer.currentTime += 1/30);

    // Fullscreen button
    document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);

    // Handle fullscreen change events
    document.addEventListener('fullscreenchange', updateFullscreenIcon);
    document.addEventListener('webkitfullscreenchange', updateFullscreenIcon);

    // Double-click video for fullscreen
    videoPlayer.addEventListener('dblclick', toggleFullscreen);

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        // Only handle if not in an input field
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        if (e.key === 'f' || e.key === 'F') {
            toggleFullscreen();
        } else if (e.key === ' ') {
            e.preventDefault();
            togglePlayPause();
        }
    });

    // Analysis controls
    analyzeBtn.addEventListener('click', startAnalysis);
    cancelBtn.addEventListener('click', cancelAnalysis);
    exportBtn.addEventListener('click', exportResults);
}

function setupDragAndDrop() {
    const uploadArea = uploadZone.querySelector('.upload-area');

    uploadArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadArea.classList.add('border-success');
    });

    uploadArea.addEventListener('dragleave', () => {
        uploadArea.classList.remove('border-success');
    });

    uploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadArea.classList.remove('border-success');

        const files = e.dataTransfer.files;
        if (files.length > 0 && files[0].type.startsWith('video/')) {
            handleFile(files[0]);
        }
    });
}

function handleFileSelect(e) {
    const file = e.target.files[0];
    if (file) handleFile(file);
}

function handleFile(file) {
    const url = URL.createObjectURL(file);
    videoPlayer.src = url;

    uploadZone.classList.add('d-none');
    playerZone.classList.remove('d-none');
    controlsCard.style.display = 'block';
    analysisCard.style.display = 'block';

    // Store filename and update header
    currentVideoFilename = file.name;
    updateVideoInfo(file.name, formatFileSize(file.size));

    // Store file for upload
    videoInput.uploadFile = file;
}

function updateVideoInfo(filename, filesize = null, isOutput = false) {
    const videoInfo = document.getElementById('videoInfo');
    const badge = isOutput ? '<span class="badge bg-success ms-2">Résultat</span>' : '';
    const size = filesize ? ` (${filesize})` : '';
    videoInfo.innerHTML = `<span class="text-light">${filename}</span>${size}${badge}`;
}

function onVideoLoaded() {
    totalTimeEl.textContent = formatTime(videoPlayer.duration);
    videoOverlay.width = videoPlayer.videoWidth;
    videoOverlay.height = videoPlayer.videoHeight;
}

function togglePlayPause() {
    if (videoPlayer.paused) {
        videoPlayer.play();
        playPauseIcon.className = 'fas fa-pause';
    } else {
        videoPlayer.pause();
        playPauseIcon.className = 'fas fa-play';
    }
}

function seekVideo() {
    const time = (progressBar.value / 100) * videoPlayer.duration;
    videoPlayer.currentTime = time;
    updateOverlayAtTime(time);
}

function updateProgress() {
    // Don't update progress bar while user is dragging it
    if (!isSeeking) {
        const progress = (videoPlayer.currentTime / videoPlayer.duration) * 100;
        progressBar.value = progress;
    }
    currentTimeEl.textContent = formatTime(videoPlayer.currentTime);

    // Update overlay and charts sync
    if (analysisData) {
        updateOverlayAtTime(videoPlayer.currentTime);
        updateChartIndicator(videoPlayer.currentTime);
    }
}

async function startAnalysis() {
    if (!videoInput.uploadFile) {
        alert('Veuillez d\'abord charger une vidéo');
        return;
    }

    isAnalyzing = true;
    analyzeBtn.style.display = 'none';
    cancelBtn.style.display = 'inline-block';
    document.getElementById('analysisProgress').style.display = 'block';

    try {
        // Create session and upload video
        const formData = new FormData();
        formData.append('video_file', videoInput.uploadFile);
        formData.append('mode', 'video');
        formData.append('enable_rppg', document.getElementById('enableRPPG').checked);
        formData.append('enable_eye_tracking', document.getElementById('enableEyes').checked);
        formData.append('enable_emotions', document.getElementById('enableEmotions').checked);
        formData.append('enable_respiration', document.getElementById('enableRespiration').checked);
        formData.append('emotion_backend', document.getElementById('emotionBackend').value);
        formData.append('enable_age_gender', document.getElementById('enableAgeGender').checked);

        const createResponse = await fetch(CONFIG.CREATE_SESSION_URL, {
            method: 'POST',
            headers: { 'X-CSRFToken': CONFIG.CSRF_TOKEN },
            body: formData
        });

        if (!createResponse.ok) {
            throw new Error(`HTTP error! status: ${createResponse.status}`);
        }

        const createData = await createResponse.json();
        if (!createData.success) throw new Error(createData.error);

        sessionId = createData.session_id;

        // Start analysis
        const startResponse = await fetch(`/lab/face-analyzer/api/sessions/${sessionId}/start/`, {
            method: 'POST',
            headers: { 'X-CSRFToken': CONFIG.CSRF_TOKEN }
        });

        if (!startResponse.ok) throw new Error('Failed to start analysis');

        // Poll for progress
        pollAnalysisProgress();

    } catch (error) {
        console.error('Analysis error:', error);
        alert('Erreur lors de l\'analyse: ' + error.message);
        resetAnalysisUI();
    }
}

async function pollAnalysisProgress() {
    if (!isAnalyzing || !sessionId) {
        // Clear any pending timeout
        if (progressPollTimeout) {
            clearTimeout(progressPollTimeout);
            progressPollTimeout = null;
        }
        return;
    }

    try {
        const response = await fetch(`/lab/face-analyzer/api/sessions/${sessionId}/status/`);
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();

        updateProgressUI(data);

        if (data.status === 'completed') {
            // Only load results if not already loaded
            if (!analysisData || !analysisData.frames || analysisData.frames.length === 0) {
                await loadAnalysisResults();
            } else {
                console.log('Analysis data already loaded, skipping reload');
            }
            // Clear polling
            if (progressPollTimeout) {
                clearTimeout(progressPollTimeout);
                progressPollTimeout = null;
            }
        } else if (data.status === 'failed') {
            throw new Error(data.error || 'Analysis failed');
        } else {
            // Schedule next poll
            progressPollTimeout = setTimeout(() => {
                pollAnalysisProgress().catch(err => {
                    console.error('Polling error:', err);
                    resetAnalysisUI();
                });
            }, 1000);
        }
    } catch (error) {
        console.error('Progress error:', error);
        // Clear polling on error
        if (progressPollTimeout) {
            clearTimeout(progressPollTimeout);
            progressPollTimeout = null;
        }
        alert('Erreur: ' + error.message);
        resetAnalysisUI();
    }
}

function updateProgressUI(data) {
    const progress = data.progress || 0;
    document.getElementById('progressBarAnalysis').style.width = progress + '%';
    document.getElementById('progressText').textContent = progress.toFixed(0) + '%';
    document.getElementById('progressStatus').textContent = data.status_message || 'En cours...';

    if (data.eta) {
        document.getElementById('progressETA').textContent = 'ETA: ' + formatTime(data.eta);
    }
}

let isLoadingResults = false;

async function loadAnalysisResults() {
    // Prevent multiple simultaneous loads
    if (isLoadingResults) {
        console.log('Already loading results, skipping...');
        return;
    }

    isLoadingResults = true;

    try {
        const response = await fetch(`/lab/face-analyzer/api/sessions/${sessionId}/frames/`);

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        analysisData = await response.json();

        console.log('Analysis data loaded:', {
            framesCount: analysisData.frames?.length || 0,
            hasSummary: !!analysisData.summary,
            firstFrame: analysisData.frames?.[0]
        });

        if (!analysisData.frames || analysisData.frames.length === 0) {
            console.warn('No frames found in analysis data');
            alert('Aucune donnée d\'analyse disponible');
            resetAnalysisUI();
            isLoadingResults = false;
            return;
        }

        // Fetch session status to get output video URL
        const statusResponse = await fetch(`/lab/face-analyzer/api/sessions/${sessionId}/status/`);
        if (statusResponse.ok) {
            const statusData = await statusResponse.json();
            if (statusData.output_url) {
                // Switch to output video
                const currentTime = videoPlayer.currentTime;
                videoPlayer.src = statusData.output_url;
                videoPlayer.currentTime = currentTime;

                // Extract filename from URL and update header
                const outputFilename = statusData.output_url.split('/').pop();
                updateVideoInfo(outputFilename, null, true);
                console.log('Switched to output video:', outputFilename);
            }
        }

        // Show results UI
        metricsRow.style.display = 'flex';
        chartsPanel.style.display = 'block';
        exportBtn.disabled = false;

        // Initialize charts with data
        initializeCharts();
        populateCharts();
        updateSummaryMetrics();

        resetAnalysisUI();

    } catch (error) {
        console.error('Error loading results:', error);
        alert('Erreur lors du chargement des résultats: ' + error.message);
        resetAnalysisUI();
    } finally {
        isLoadingResults = false;
    }
}

let isLoadingExistingSession = false;

async function loadExistingSession(existingSessionId) {
    // Prevent multiple simultaneous loads
    if (isLoadingExistingSession || isLoadingResults) {
        console.log('Already loading session or results, skipping...');
        return;
    }

    isLoadingExistingSession = true;
    sessionId = existingSessionId;

    try {
        const statusResponse = await fetch(`/lab/face-analyzer/api/sessions/${sessionId}/status/`);

        if (!statusResponse.ok) {
            throw new Error(`HTTP error! status: ${statusResponse.status}`);
        }

        const statusData = await statusResponse.json();
        console.log('Session status:', statusData.status);

        if (statusData.status === 'completed') {
            // Prefer output video if available, otherwise use input
            const videoUrl = statusData.output_url || statusData.input_file;
            const isOutput = !!statusData.output_url;

            if (videoUrl) {
                videoPlayer.src = videoUrl;
                uploadZone.classList.add('d-none');
                playerZone.classList.remove('d-none');
                controlsCard.style.display = 'block';
                analysisCard.style.display = 'block';

                // Extract filename from URL and update header
                const filename = videoUrl.split('/').pop();
                updateVideoInfo(filename, null, isOutput);
            }

            // Only load results once
            if (!analysisData || !analysisData.frames || analysisData.frames.length === 0) {
                await loadAnalysisResults();
            } else {
                console.log('Analysis data already loaded, skipping reload');
            }
        } else if (statusData.status === 'pending' && statusData.input_file) {
            // Session pending - load input video for analysis
            videoPlayer.src = statusData.input_file;
            uploadZone.classList.add('d-none');
            playerZone.classList.remove('d-none');
            controlsCard.style.display = 'block';
            analysisCard.style.display = 'block';

            // Extract filename from URL and update header
            const filename = statusData.input_file.split('/').pop();
            updateVideoInfo(filename, null, false);
            console.log('Loaded pending session with input file:', filename);
        }
    } catch (error) {
        console.error('Error loading session:', error);
    } finally {
        isLoadingExistingSession = false;
    }
}

async function cancelAnalysis() {
    if (!sessionId) return;

    // Stop polling immediately
    isAnalyzing = false;
    if (progressPollTimeout) {
        clearTimeout(progressPollTimeout);
        progressPollTimeout = null;
    }

    try {
        const response = await fetch(`/lab/face-analyzer/api/sessions/${sessionId}/cancel/`, {
            method: 'POST',
            headers: { 'X-CSRFToken': CONFIG.CSRF_TOKEN }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        if (data.success) {
            console.log('Cancellation requested');
        }
    } catch (error) {
        console.error('Cancel error:', error);
    }

    resetAnalysisUI();
}

function resetAnalysisUI() {
    isAnalyzing = false;
    // Clear any pending polling
    if (progressPollTimeout) {
        clearTimeout(progressPollTimeout);
        progressPollTimeout = null;
    }
    analyzeBtn.style.display = 'inline-block';
    cancelBtn.style.display = 'none';
    document.getElementById('analysisProgress').style.display = 'none';
}

// Current video time for chart synchronization
let currentVideoTime = 0;

// Custom Chart.js plugin for vertical time line
const verticalLinePlugin = {
    id: 'verticalLine',
    afterDraw: (chart) => {
        if (!analysisData || !analysisData.frames || analysisData.frames.length === 0) return;

        const ctx = chart.ctx;
        const xScale = chart.scales.x;
        const yScale = chart.scales.y;

        // Find the data index closest to current video time
        let dataIndex = 0;
        for (let i = 0; i < analysisData.frames.length; i++) {
            if (analysisData.frames[i].timestamp >= currentVideoTime) {
                dataIndex = i;
                break;
            }
            dataIndex = i;
        }

        // Get pixel position for this data point
        const x = xScale.getPixelForValue(dataIndex);

        if (x >= xScale.left && x <= xScale.right) {
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(x, yScale.top);
            ctx.lineTo(x, yScale.bottom);
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.stroke();

            // Draw small triangle at top
            ctx.beginPath();
            ctx.moveTo(x - 5, yScale.top);
            ctx.lineTo(x + 5, yScale.top);
            ctx.lineTo(x, yScale.top + 8);
            ctx.closePath();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fill();
            ctx.restore();
        }
    }
};

// Register the plugin globally
Chart.register(verticalLinePlugin);

function initializeCharts() {
    // Destroy existing charts if they exist
    Object.keys(charts).forEach(key => {
        if (charts[key]) {
            charts[key].destroy();
            charts[key] = null;
        }
    });

    const chartOptions = {
        responsive: true,
        maintainAspectRatio: true,
        animation: false,
        plugins: {
            legend: { display: false },
            tooltip: {
                enabled: true,
                mode: 'index',
                intersect: false,
                callbacks: {
                    title: (items) => {
                        if (items.length > 0 && analysisData && analysisData.frames) {
                            const frame = analysisData.frames[items[0].dataIndex];
                            return frame ? formatTime(frame.timestamp) : '';
                        }
                        return '';
                    }
                }
            }
        },
        scales: {
            x: {
                display: true,
                grid: { color: 'rgba(255,255,255,0.05)' },
                ticks: {
                    color: '#888',
                    maxTicksLimit: 10,
                    callback: function(value, index) {
                        // Show time label every few ticks
                        if (analysisData && analysisData.frames && analysisData.frames[value]) {
                            return formatTime(analysisData.frames[value].timestamp);
                        }
                        return '';
                    }
                }
            },
            y: {
                grid: { color: 'rgba(255,255,255,0.1)' },
                ticks: { color: '#aaa' }
            }
        },
        onClick: (e, elements, chart) => {
            const canvasPosition = Chart.helpers.getRelativePosition(e, chart);
            const dataX = chart.scales.x.getValueForPixel(canvasPosition.x);
            if (analysisData && analysisData.frames && analysisData.frames[Math.round(dataX)]) {
                const timestamp = analysisData.frames[Math.round(dataX)].timestamp;
                videoPlayer.currentTime = timestamp;
            }
        }
    };

    // Heart Rate
    const hrCanvas = document.getElementById('hrChart');
    if (hrCanvas) {
        charts.hr = new Chart(hrCanvas, {
            type: 'line',
            data: { 
                labels: [], 
                datasets: [{ 
                    data: [], 
                    borderColor: '#dc3545', 
                    backgroundColor: 'rgba(220, 53, 69, 0.1)',
                    tension: 0.4, 
                    pointRadius: 2,
                    pointHoverRadius: 4,
                    spanGaps: true
                }] 
            },
            options: {
                ...chartOptions,
                scales: {
                    x: { display: true, title: { display: true, text: 'Temps', color: '#aaa' }, ...chartOptions.scales.x },
                    y: { ...chartOptions.scales.y, suggestedMin: 50, suggestedMax: 120, title: { display: true, text: 'BPM', color: '#aaa' } }
                }
            }
        });
    }

    // HRV
    const hrvCanvas = document.getElementById('hrvChart');
    if (hrvCanvas) {
        charts.hrv = new Chart(hrvCanvas, {
            type: 'line',
            data: { 
                labels: [], 
                datasets: [{ 
                    data: [], 
                    borderColor: '#ffc107', 
                    backgroundColor: 'rgba(255, 193, 7, 0.1)',
                    tension: 0.4, 
                    pointRadius: 2,
                    pointHoverRadius: 4,
                    spanGaps: true
                }] 
            },
            options: {
                ...chartOptions,
                scales: {
                    x: { display: true, title: { display: true, text: 'Temps', color: '#aaa' }, ...chartOptions.scales.x },
                    y: { ...chartOptions.scales.y, beginAtZero: true, suggestedMax: 150, title: { display: true, text: 'RMSSD (ms)', color: '#aaa' } }
                }
            }
        });
    }

    // Emotions (stacked area)
    const emotionsCanvas = document.getElementById('emotionsChart');
    if (emotionsCanvas) {
        charts.emotions = new Chart(emotionsCanvas, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    { label: 'Neutre', data: [], borderColor: '#6c757d', backgroundColor: 'rgba(108,117,125,0.3)', fill: true, tension: 0.4, pointRadius: 0 },
                    { label: 'Joie', data: [], borderColor: '#ffc107', backgroundColor: 'rgba(255,193,7,0.3)', fill: true, tension: 0.4, pointRadius: 0 },
                    { label: 'Tristesse', data: [], borderColor: '#0d6efd', backgroundColor: 'rgba(13,110,253,0.3)', fill: true, tension: 0.4, pointRadius: 0 },
                    { label: 'Colère', data: [], borderColor: '#dc3545', backgroundColor: 'rgba(220,53,69,0.3)', fill: true, tension: 0.4, pointRadius: 0 },
                    { label: 'Surprise', data: [], borderColor: '#0dcaf0', backgroundColor: 'rgba(13,202,240,0.3)', fill: true, tension: 0.4, pointRadius: 0 }
                ]
            },
            options: { ...chartOptions, plugins: { legend: { display: true, labels: { color: '#aaa', boxWidth: 10 } } } }
        });
    }

    // PERCLOS with blink markers
    const perclosCanvas = document.getElementById('perclosChart');
    if (perclosCanvas) {
        charts.perclos = new Chart(perclosCanvas, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    {
                        label: 'PERCLOS',
                        data: [],
                        borderColor: '#0dcaf0',
                        tension: 0.4,
                        pointRadius: 1,
                        pointHoverRadius: 3,
                        fill: true,
                        backgroundColor: 'rgba(13,202,240,0.2)',
                        order: 1
                    },
                    {
                        label: 'Clignements',
                        data: [],
                        type: 'scatter',
                        borderColor: '#ffc107',
                        backgroundColor: '#ffc107',
                        pointRadius: 6,
                        pointStyle: 'triangle',
                        showLine: false,
                        order: 0
                    }
                ]
            },
            options: {
                ...chartOptions,
                scales: {
                    ...chartOptions.scales,
                    x: {
                        ...chartOptions.scales.x,
                        display: true,
                        title: { display: true, text: 'Temps', color: '#aaa' }
                    },
                    y: { ...chartOptions.scales.y, min: 0, max: 100, title: { display: true, text: '%', color: '#aaa' } }
                },
                plugins: {
                    ...chartOptions.plugins,
                    legend: {
                        display: true,
                        position: 'top',
                        align: 'end',
                        labels: { color: '#aaa', boxWidth: 12, padding: 8, font: { size: 10 } }
                    }
                },
                maintainAspectRatio: false
            }
        });
    }

    // Blink rate
    const blinkCanvas = document.getElementById('blinkChart');
    if (blinkCanvas) {
        charts.blink = new Chart(blinkCanvas, {
            type: 'bar',
            data: { labels: [], datasets: [{ label: 'Clignements/s', data: [], backgroundColor: '#0dcaf0' }] },
            options: {
                ...chartOptions,
                scales: {
                    x: {
                        ...chartOptions.scales.x,
                        display: true,
                        title: { display: true, text: 'Temps', color: '#aaa' }
                    },
                    y: { ...chartOptions.scales.y, beginAtZero: true, title: { display: true, text: 'Nb', color: '#aaa' } }
                },
                maintainAspectRatio: false
            }
        });
    }

    // Respiration
    const respirationCanvas = document.getElementById('respirationChart');
    if (respirationCanvas) {
        charts.respiration = new Chart(respirationCanvas, {
            type: 'line',
            data: { 
                labels: [], 
                datasets: [{ 
                    data: [], 
                    borderColor: '#198754', 
                    backgroundColor: 'rgba(25,135,84,0.1)',
                    tension: 0.4, 
                    pointRadius: 2,
                    pointHoverRadius: 4,
                    fill: true, 
                    spanGaps: true
                }] 
            },
            options: {
                ...chartOptions,
                scales: {
                    x: { display: true, title: { display: true, text: 'Temps', color: '#aaa' }, ...chartOptions.scales.x },
                    y: { ...chartOptions.scales.y, suggestedMin: 10, suggestedMax: 20, title: { display: true, text: 'Resp/min', color: '#aaa' } }
                }
            }
        });
    }

    console.log('Charts initialized:', Object.keys(charts));
}

function populateCharts() {
    if (!analysisData || !analysisData.frames) {
        console.warn('No analysis data or frames available for charts');
        return;
    }

    const frames = analysisData.frames;
    if (frames.length === 0) {
        console.warn('Frames array is empty');
        return;
    }

    // Use timestamps as labels for better visualization
    const labels = frames.map(f => formatTime(f.timestamp || 0));
    console.log(`Populating charts with ${frames.length} frames`);

    // Heart Rate
    if (charts.hr) {
        const hrData = frames.map(f => {
            if (f.rppg && typeof f.rppg === 'object') {
                const hr = f.rppg.heart_rate || f.rppg.hr;
                return hr !== undefined && hr !== null ? hr : null;
            }
            return null;
        });
        
        charts.hr.data.labels = labels;
        charts.hr.data.datasets[0].data = hrData;
        charts.hr.update('none');
        console.log(`HR chart: ${hrData.filter(v => v !== null).length} non-null values out of ${frames.length} frames`);
    }

    // HRV
    if (charts.hrv) {
        const hrvData = frames.map(f => {
            if (f.rppg && f.rppg.hrv) {
                const rmssd = f.rppg.hrv.rmssd || f.rppg.hrv.rmssd_value;
                return rmssd !== undefined && rmssd !== null ? rmssd : null;
            }
            if (f.rppg && f.rppg.rmssd !== undefined) {
                return f.rppg.rmssd;
            }
            return null;
        });

        // Debug: show sample HRV data
        const framesWithHrv = frames.filter(f => f.rppg && f.rppg.hrv && f.rppg.hrv.rmssd);
        if (framesWithHrv.length > 0) {
            console.log('Sample HRV data:', framesWithHrv[0].rppg.hrv);
            const hrvValues = hrvData.filter(v => v !== null);
            if (hrvValues.length > 0) {
                console.log(`HRV range: min=${Math.min(...hrvValues).toFixed(1)}, max=${Math.max(...hrvValues).toFixed(1)}, avg=${(hrvValues.reduce((a,b) => a+b, 0) / hrvValues.length).toFixed(1)}`);
            }
        }

        charts.hrv.data.labels = labels;
        charts.hrv.data.datasets[0].data = hrvData;
        charts.hrv.update('none');
        console.log(`HRV chart: ${hrvData.filter(v => v !== null).length} non-null values out of ${frames.length} frames`);
    }

    // Emotions
    if (charts.emotions) {
        const emotionKeys = ['neutral', 'happy', 'sad', 'angry', 'surprise'];
        charts.emotions.data.labels = labels;

        // Debug: log sample emotion data
        const framesWithEmotions = frames.filter(f => f.emotions && typeof f.emotions === 'object');
        console.log(`Emotions chart: ${framesWithEmotions.length} frames with emotion data out of ${frames.length}`);
        if (framesWithEmotions.length > 0) {
            console.log('Sample emotion data:', framesWithEmotions[0].emotions);
        }

        emotionKeys.forEach((key, i) => {
            if (charts.emotions.data.datasets[i]) {
                const emotionData = frames.map(f => {
                    if (f.emotions && typeof f.emotions === 'object') {
                        return f.emotions[key] || f.emotions[key.toLowerCase()] || 0;
                    }
                    return 0;
                });
                charts.emotions.data.datasets[i].data = emotionData;

                // Debug: count non-zero values for this emotion
                const nonZero = emotionData.filter(v => v > 0).length;
                if (nonZero > 0) {
                    console.log(`  ${key}: ${nonZero} non-zero values`);
                }
            }
        });
        charts.emotions.update('none');
    }

    // PERCLOS with blink markers
    if (charts.perclos) {
        const perclosData = frames.map(f => {
            if (f.eye_tracking && typeof f.eye_tracking === 'object') {
                const perclos = f.eye_tracking.perclos || f.eye_tracking.perclos_value || 0;
                return perclos * 100; // Convert to percentage
            }
            return 0;
        });

        // Extract blink events as scatter points (show at Y=80 when blink detected)
        const blinkData = frames.map((f, i) => {
            if (f.eye_tracking && (f.eye_tracking.blink_detected || f.eye_tracking.blink?.is_blinking)) {
                return 80; // Fixed Y position for blink markers
            }
            return null;
        });

        charts.perclos.data.labels = labels;
        charts.perclos.data.datasets[0].data = perclosData;
        charts.perclos.data.datasets[1].data = blinkData;
        charts.perclos.update('none');

        // Debug: count blinks
        const blinkCount = blinkData.filter(v => v !== null).length;
        console.log(`PERCLOS chart: ${blinkCount} blinks detected out of ${frames.length} frames`);
    }

    // Blink (aggregate per second)
    if (charts.blink) {
        const blinkData = aggregateBlinkData(frames);
        charts.blink.data.labels = blinkData.labels;
        charts.blink.data.datasets[0].data = blinkData.values;
        charts.blink.update('none');
    }

    // Respiration
    if (charts.respiration) {
        const respData = frames.map(f => {
            if (f.respiration && typeof f.respiration === 'object') {
                const rate = f.respiration.rate || f.respiration.respiratory_rate;
                return rate !== undefined && rate !== null ? rate : null;
            }
            return null;
        });
        
        charts.respiration.data.labels = labels;
        charts.respiration.data.datasets[0].data = respData;
        charts.respiration.update('none');
        console.log(`Respiration chart: ${respData.filter(v => v !== null).length} non-null values out of ${frames.length} frames`);
    }

    console.log('Charts populated successfully');
}

function aggregateBlinkData(frames) {
    const buckets = {};
    let totalBlinks = 0;

    frames.forEach(f => {
        if (f.eye_tracking?.blink_detected) {
            const second = Math.floor(f.timestamp);
            buckets[second] = (buckets[second] || 0) + 1;
            totalBlinks++;
        }
    });

    // Use the last frame's timestamp (video duration) instead of last blink
    const lastTimestamp = frames.length > 0 ? frames[frames.length - 1].timestamp : 0;
    const maxSecond = Math.ceil(lastTimestamp);

    const labels = [];
    const values = [];
    for (let i = 0; i <= maxSecond; i++) {
        labels.push(formatTime(i));
        values.push(buckets[i] || 0);
    }

    console.log(`Blink aggregation: ${totalBlinks} blinks over ${maxSecond} seconds`);
    return { labels, values, totalBlinks, durationSeconds: maxSecond };
}

function updateSummaryMetrics() {
    if (!analysisData || !analysisData.summary) {
        console.warn('No summary data available');
        // Try to calculate from frames if summary is missing
        if (analysisData && analysisData.frames && analysisData.frames.length > 0) {
            calculateSummaryFromFrames();
        }
        return;
    }

    const summary = analysisData.summary;
    console.log('Updating summary metrics:', summary);

    // Heart Rate
    if (document.getElementById('avgHR')) {
        document.getElementById('avgHR').textContent = summary.avg_heart_rate?.toFixed(0) || '--';
    }

    // SpO2
    if (document.getElementById('avgSpO2')) {
        document.getElementById('avgSpO2').textContent = summary.avg_spo2?.toFixed(0) || '--';
    }

    // Respiration
    if (document.getElementById('avgRR')) {
        document.getElementById('avgRR').textContent = summary.avg_respiration?.toFixed(1) || '--';
    }

    // Blink rate
    if (document.getElementById('avgBlink')) {
        document.getElementById('avgBlink').textContent = summary.avg_blink_rate?.toFixed(1) || '--';
    }

    // Age
    if (document.getElementById('detectedAge')) {
        document.getElementById('detectedAge').textContent = summary.detected_age || '--';
    }

    // Gender
    if (document.getElementById('detectedGender')) {
        const gender = summary.detected_gender;
        if (gender) {
            document.getElementById('detectedGender').textContent = gender === 'Man' ? 'Homme' : (gender === 'Woman' ? 'Femme' : gender);
            const genderIcon = document.getElementById('genderIcon');
            if (genderIcon) {
                if (gender === 'Man') {
                    genderIcon.className = 'fas fa-mars text-info';
                } else if (gender === 'Woman') {
                    genderIcon.className = 'fas fa-venus text-pink';
                }
            }
        } else {
            document.getElementById('detectedGender').textContent = '--';
        }
    }

    // HRV (RMSSD)
    if (document.getElementById('avgHRV')) {
        const hrvValue = summary.avg_hrv?.toFixed(1);
        document.getElementById('avgHRV').textContent = hrvValue ? hrvValue + ' ms' : '-- ms';
    }

    // Dominant Emotion
    if (document.getElementById('dominantEmotion')) {
        document.getElementById('dominantEmotion').textContent = summary.dominant_emotion || '--';
    }

    // Show the second metrics row
    const metricsRow2 = document.getElementById('metricsRow2');
    if (metricsRow2) metricsRow2.style.display = 'flex';
}

function calculateSummaryFromFrames() {
    if (!analysisData || !analysisData.frames || analysisData.frames.length === 0) return;

    const frames = analysisData.frames;
    const hrValues = [];
    const hrvValues = [];
    const rrValues = [];
    const spo2Values = [];
    const blinkRates = [];
    const ages = [];
    const genders = {};
    const emotions = {};

    frames.forEach(f => {
        if (f.rppg && f.rppg.heart_rate !== undefined && f.rppg.heart_rate !== null) {
            hrValues.push(f.rppg.heart_rate);
        }
        if (f.rppg && f.rppg.hrv && f.rppg.hrv.rmssd !== undefined && f.rppg.hrv.rmssd !== null) {
            hrvValues.push(f.rppg.hrv.rmssd);
        }
        if (f.rppg && f.rppg.spo2 !== undefined && f.rppg.spo2 !== null && f.rppg.spo2 > 0) {
            spo2Values.push(f.rppg.spo2);
        }
        if (f.respiration && f.respiration.rate !== undefined && f.respiration.rate !== null) {
            rrValues.push(f.respiration.rate);
        }
        if (f.eye_tracking && f.eye_tracking.blink?.blink_rate !== undefined) {
            blinkRates.push(f.eye_tracking.blink.blink_rate);
        }
        if (f.emotions) {
            if (f.emotions.age !== undefined && f.emotions.age !== null) {
                ages.push(f.emotions.age);
            }
            if (f.emotions.gender) {
                genders[f.emotions.gender] = (genders[f.emotions.gender] || 0) + 1;
            }
            const dominant = f.emotions.dominant_emotion || f.emotions.dominant;
            if (dominant) {
                emotions[dominant] = (emotions[dominant] || 0) + 1;
            }
        }
    });

    const summary = {};
    if (hrValues.length > 0) {
        summary.avg_heart_rate = hrValues.reduce((a, b) => a + b, 0) / hrValues.length;
    }
    if (hrvValues.length > 0) {
        summary.avg_hrv = hrvValues.reduce((a, b) => a + b, 0) / hrvValues.length;
    }
    if (rrValues.length > 0) {
        summary.avg_respiration = rrValues.reduce((a, b) => a + b, 0) / rrValues.length;
    }
    if (spo2Values.length > 0) {
        summary.avg_spo2 = spo2Values.reduce((a, b) => a + b, 0) / spo2Values.length;
    }
    if (blinkRates.length > 0) {
        summary.avg_blink_rate = blinkRates.reduce((a, b) => a + b, 0) / blinkRates.length;
    }
    if (ages.length > 0) {
        // Use median age for better accuracy
        ages.sort((a, b) => a - b);
        summary.detected_age = ages[Math.floor(ages.length / 2)];
    }
    if (Object.keys(genders).length > 0) {
        summary.detected_gender = Object.entries(genders).reduce((a, b) => a[1] > b[1] ? a : b)[0];
    }
    if (Object.keys(emotions).length > 0) {
        summary.dominant_emotion = Object.entries(emotions).reduce((a, b) => a[1] > b[1] ? a : b)[0];
    }

    if (Object.keys(summary).length > 0) {
        analysisData.summary = summary;
        updateSummaryMetrics();
    }
}

function updateOverlayAtTime(time) {
    if (!analysisData || !analysisData.frames) return;

    // Find frame closest to current time
    const frameIndex = analysisData.frames.findIndex(f => f.timestamp >= time);
    if (frameIndex < 0) return;

    const frame = analysisData.frames[frameIndex];

    overlayCtx.clearRect(0, 0, videoOverlay.width, videoOverlay.height);

    // Draw face bbox
    if (frame.face_bbox) {
        const [x, y, w, h] = frame.face_bbox;
        overlayCtx.strokeStyle = '#0dcaf0';
        overlayCtx.lineWidth = 2;
        overlayCtx.strokeRect(x, y, w, h);
    }

    // Update HR badge and overlay
    const hrBadge = document.getElementById('currentHR');
    if (frame.rppg?.heart_rate) {
        overlayCtx.fillStyle = '#dc3545';
        overlayCtx.font = 'bold 20px Arial';
        overlayCtx.textAlign = 'left';
        overlayCtx.fillText('❤ ' + frame.rppg.heart_rate.toFixed(0) + ' BPM', 10, 30);
        if (hrBadge) hrBadge.textContent = frame.rppg.heart_rate.toFixed(0) + ' BPM';
    } else {
        if (hrBadge) hrBadge.textContent = '-- BPM';
    }

    // Update SpO2 on overlay
    if (frame.rppg?.spo2 && frame.rppg.spo2 > 0) {
        overlayCtx.fillStyle = '#0d6efd';
        overlayCtx.font = 'bold 16px Arial';
        overlayCtx.textAlign = 'left';
        overlayCtx.fillText('SpO2: ' + frame.rppg.spo2.toFixed(0) + '%', 10, 52);
    }

    // Update HRV badge
    const hrvBadge = document.getElementById('currentHRV');
    if (frame.rppg?.hrv?.rmssd) {
        if (hrvBadge) hrvBadge.textContent = frame.rppg.hrv.rmssd.toFixed(1) + ' ms';
    } else {
        if (hrvBadge) hrvBadge.textContent = '-- ms';
    }

    // Update Emotion badge and Age/Gender on overlay
    const emotionBadge = document.getElementById('currentEmotion');
    if (frame.emotions) {
        const emotion = frame.emotions.dominant_emotion || frame.emotions.dominant;
        if (emotion) {
            overlayCtx.fillStyle = '#ffc107';
            overlayCtx.font = 'bold 16px Arial';
            overlayCtx.textAlign = 'left';
            overlayCtx.fillText(emotion.toUpperCase(), 10, videoOverlay.height - 10);
            if (emotionBadge) emotionBadge.textContent = emotion.charAt(0).toUpperCase() + emotion.slice(1);
        }

        // Age/Gender on overlay (top right)
        if (frame.emotions.age || frame.emotions.gender) {
            overlayCtx.fillStyle = '#aaa';
            overlayCtx.font = '14px Arial';
            overlayCtx.textAlign = 'right';
            let infoText = '';
            if (frame.emotions.gender) {
                infoText = frame.emotions.gender === 'Man' ? '♂' : (frame.emotions.gender === 'Woman' ? '♀' : '');
            }
            if (frame.emotions.age) {
                infoText += ' ' + frame.emotions.age + ' ans';
            }
            overlayCtx.fillText(infoText.trim(), videoOverlay.width - 10, videoOverlay.height - 10);
        }
    } else {
        if (emotionBadge) emotionBadge.textContent = '--';
    }

    // Update PERCLOS badge
    const perclosBadge = document.getElementById('currentPERCLOS');
    if (frame.eye_tracking?.perclos !== undefined) {
        const perclosValue = (frame.eye_tracking.perclos * 100).toFixed(0);
        if (perclosBadge) perclosBadge.textContent = perclosValue + ' %';
    } else {
        if (perclosBadge) perclosBadge.textContent = '-- %';
    }

    // Update Respiration badge
    const respBadge = document.getElementById('currentRespiration');
    const respRate = frame.respiration?.rate || frame.respiration?.respiratory_rate;
    if (respRate !== undefined && respRate !== null) {
        if (respBadge) respBadge.textContent = respRate.toFixed(1) + ' /min';
    } else {
        if (respBadge) respBadge.textContent = '-- /min';
    }
}

function updateChartIndicator(time) {
    // Update global time variable for the vertical line plugin
    currentVideoTime = time;

    // Request chart updates (throttled to avoid performance issues)
    if (!updateChartIndicator.pending) {
        updateChartIndicator.pending = true;
        requestAnimationFrame(() => {
            Object.values(charts).forEach(chart => {
                if (chart) {
                    chart.update('none'); // 'none' mode for faster update without animation
                }
            });
            updateChartIndicator.pending = false;
        });
    }
}

function exportResults() {
    if (!analysisData) return;

    const blob = new Blob([JSON.stringify(analysisData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `face_analysis_${sessionId || 'export'}.json`;
    a.click();
    URL.revokeObjectURL(url);
}

// Fullscreen functions
function toggleFullscreen() {
    const videoContainer = document.getElementById('videoContainer');

    if (!document.fullscreenElement && !document.webkitFullscreenElement) {
        // Enter fullscreen
        if (videoContainer.requestFullscreen) {
            videoContainer.requestFullscreen();
        } else if (videoContainer.webkitRequestFullscreen) {
            videoContainer.webkitRequestFullscreen();
        }
    } else {
        // Exit fullscreen
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        }
    }
}

function updateFullscreenIcon() {
    const icon = document.getElementById('fullscreenIcon');
    if (document.fullscreenElement || document.webkitFullscreenElement) {
        icon.className = 'fas fa-compress';
    } else {
        icon.className = 'fas fa-expand';
    }
}

// Utility functions
function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

function formatFileSize(bytes) {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
    return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
}
</script>

<style>
.upload-area {
    cursor: pointer;
    transition: border-color 0.2s, background-color 0.2s;
}

.upload-area:hover {
    border-color: #198754 !important;
    background-color: rgba(25, 135, 84, 0.1);
}

.border-dashed {
    border-style: dashed !important;
}

#videoPlayer {
    display: block;
}

.progress {
    border-radius: 0.25rem;
}

/* Fullscreen styles */
#videoContainer:fullscreen,
#videoContainer:-webkit-full-screen {
    background: #000;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100vw;
    height: 100vh;
}

#videoContainer:fullscreen #playerZone,
#videoContainer:-webkit-full-screen #playerZone {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
}

#videoContainer:fullscreen #videoPlayer,
#videoContainer:-webkit-full-screen #videoPlayer {
    max-height: 100vh;
    max-width: 100vw;
    width: 100%;
    height: 100%;
    object-fit: contain;
}

#videoContainer:fullscreen #videoOverlay,
#videoContainer:-webkit-full-screen #videoOverlay {
    max-height: 100vh;
    max-width: 100vw;
    width: 100%;
    height: 100%;
    object-fit: contain;
}

#videoContainer:fullscreen #uploadZone,
#videoContainer:-webkit-full-screen #uploadZone {
    display: none !important;
}
</style>
{% endblock %}
